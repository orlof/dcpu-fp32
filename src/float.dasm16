; Public api functions are marked as extern
; Arguments are pushed to stack in right to left
; int16 values and memory addresses are returned in stack


;TODO ALL RETURN I MAY BE JUST RETURN


;----------------------------------------------------------------
; extern int16 float_cmp(float *left, float *right)
;----------------------------------------------------------------
:float_cmp
    set push, [sp]              ; make room for return value

    set push, i                 ; store registers
    set push, j

	;---------------------------------------
    ; [sp + 5] 2. arg
    ; [sp + 4] 1. arg
    ; [sp + 3] return value
    ; [sp + 2] rts
    ; [sp + 1] i
    ; [sp + 0] j
	;---------------------------------------

	set i, [sp + 4]             ; float *left
	set j, [sp + 5]             ; float *right

	; compare types
    set [sp + 3], 0             ; zero return value

    ifu [i], [j]
        set [sp + 3], 1

    ifa [i], [j]
        set [sp + 3], -1

    ifn [sp + 3], 0             ; different types?
        set pc, float_cmp__finish 
	; left.type == right.type

	ifn [i], FLOAT_TYPE_PNUM    ; special values?
    	ifn [i], FLOAT_TYPE_NNUM
            set pc, float_cmp__finish 

	; compare two positive or two negative numbers
    jsr _float_cmp_abs
    set [sp + 3], pop

    ; negate result if arguments are negative
	ifa [i], 0
		mli [sp + 3], -1

:float_cmp__finish
	;---------------------------------------
	; postamble
	;---------------------------------------
    set j, pop
    set i, pop
	set pc, pop


;----------------------------------------------------------------
:_float_cmp_abs
; fastcall
;  i: float *left
;  j: float *right
; return
;  [sp]: 
;    1 if abs(left) > abs(right)
;    0 if abs(left) == abs(right)
;   -1 if abs(left) < abs(right)
;----------------------------------------------------------------
    set push, [sp]
    set [sp+1], 0
    ; compare low
	ifg [i + FLOAT_LOW], [j + FLOAT_LOW]
        set [sp + 1], 1
	ifl [i + FLOAT_LOW], [j + FLOAT_LOW]
        set [sp + 1], -1

    ; compare high
	ifg [i + FLOAT_HIGH], [j + FLOAT_HIGH]
        set [sp + 1], 1
	ifl [i + FLOAT_HIGH], [j + FLOAT_HIGH]
        set [sp + 1], -1

    ; compare exp
	ifg [i + FLOAT_EXP], [j + FLOAT_EXP]
        set [sp + 1], 1
	ifl [i + FLOAT_EXP], [j + FLOAT_EXP]
        set [sp + 1], -1

    set pc, pop

;----------------------------------------------------------------
; extern void float_sub(float *left, float *right, float *result)
;----------------------------------------------------------------
:float_sub
    set push, i                 ; store i
    set i, [sp + 3]             ; float *right

    ; copy right
    set push, [i + FLOAT_LOW]
    set push, [i + FLOAT_HIGH]
    set push, [i + FLOAT_EXP]
    set push, [i + FLOAT_TYPE]
    set i, sp

    mli [i], -1                 ; negate right

	;---------------------------------------
    ; [sp + 8] float *result
    ; [sp + 7] float *right
    ; [sp + 6] float *left
    ; [sp + 5] rts
    ; [sp + 4] i
    ; [sp + 3] tmp.low
    ; [sp + 2] tmp.high
    ; [sp + 1] tmp.exp
    ; [sp + 0] tmp.type

    ; make float_add call
    set push, [sp + 8]          ; original result
    set push, i                 ; negated right
    set push, [sp + 8]          ; original left
    jsr float_add

    add sp, 7                   ; clean stack (negated right, add arguments)
    set i, pop                  ; restore i

    set pc, pop

;----------------------------------------------------------------
; void float_add(float *left, float *right, float *result)
;----------------------------------------------------------------
:float_add
    set push, a                 ; store registers
    set push, b
    set push, c
    set push, i
    set push, j

	;---------------------------------------
    ; [sp + 8] float *result
    ; [sp + 7] float *right
    ; [sp + 6] float *left
    ; [sp + 5] rts
    ; [sp + 4] a
    ; [sp + 3] b
    ; [sp + 2] c
    ; [sp + 1] i
    ; [sp + 0] j

	set i, [sp + 6]     ; float *left
	set j, [sp + 7]     ; float *right

	;---------------------------------------
	; check special cases
	;---------------------------------------
    ife [i], FLOAT_TYPE_NAN
        set pc, float__return_nan
    ife [j], FLOAT_TYPE_NAN
        set pc, float__return_nan

	set b, [j]
	add b, 3
	ifa [j], 0
		sub b, 1
	mul b, 6
	
	add b, [i]
	add b, 3
	ifa [i], 0
		sub b, 1
	
	set pc, [b + float_add__special_values]

:float_add__special_values
	;   inf,                num,                0.0,                 -0.0,                -num,              -inf
	dat	float__return_pinf, float__return_pinf, float__return_pinf,  float__return_pinf,  float__return_pinf, float__return_nan  ; inf
	dat	float__return_pinf, float__add_num,     float__return_j,     float__return_j,     float__add_num,     float__return_ninf ; num
	dat	float__return_pinf, float__return_i,    float__return_pzero, float__return_pzero, float__return_i,    float__return_ninf ; 0.0
	dat	float__return_pinf, float__return_i,    float__return_pzero, float__return_nzero, float__return_i,    float__return_ninf ; -0.0
	dat	float__return_pinf, float__add_num,     float__return_j,     float__return_j,     float__add_num,     float__return_ninf ; -num
	dat	float__return_nan,  float__return_ninf, float__return_ninf,  float__return_ninf,  float__return_ninf, float__return_ninf ; -inf

:float__add_num
	;---------------------------------------
    ; i = clone(abs(left) >= abs(right) ? left: right)
    ; j = abs(left) < abs(right) ? left: right
	;---------------------------------------
    jsr _float_cmp_abs

	; i = max(left, right)
	; j = min(left, right)
    ife -1, pop
        set i, j                ; i = float *right
    ife i, j
        set j, [sp + 6]         ; j = float *left

	;---------------------------------------
	; align exponents
	;---------------------------------------

	; calculate exponent diff
	set c, [i + FLOAT_EXP]
	sub c, [j + FLOAT_EXP]
	
	; quick exit if j is too small
	ifg c, 31
		set pc, float__return_i

	; shift mantissa for calculation
	set b, [j + FLOAT_LOW]
	shr b, c

	set a, [j + FLOAT_HIGH]
	shr a, c

    ; copy max(left, right) to result
    set c, [sp + 8]
    set [c + FLOAT_TYPE], [i + FLOAT_TYPE]
    set [c + FLOAT_EXP], [i + FLOAT_EXP]
    set [c + FLOAT_HIGH], [i + FLOAT_HIGH]
    set [c + FLOAT_LOW], [i + FLOAT_LOW]

	; which method to use?
	ife [i], [j]                ; sgn(i) == sgn(j)
		set pc, float_add__op_add

:float_add__op_sub
	bor b, ex
	
	sub [c + FLOAT_LOW], b
	sbx [c + FLOAT_HIGH], a

    ife [c + FLOAT_LOW], 0
        ife [c + FLOAT_HIGH], 0
            set pc, float__return_pzero
	
	; normalize result
	jsr nlz
	
	shl [c + FLOAT_HIGH], a
	shl [c + FLOAT_LOW], a
	bor [c + FLOAT_HIGH], ex
	
	sub [c + FLOAT_EXP], a
	ife ex, 0
		set pc, float__return
		
	set pc, float__return_zero

:float_add__op_add
	adx [c + FLOAT_LOW], b
	adx [c + FLOAT_HIGH], a

    ife [c + FLOAT_LOW], 0
        ife [c + FLOAT_HIGH], 0
            ife ex, 0
                set pc, float__return_pzero

	ife ex, 0							; no overflow?
		set pc, float__return

	; normalize result
	shr [c + FLOAT_LOW], 1
	shr [c + FLOAT_HIGH], 1
	bor [c + FLOAT_LOW], ex
	bor [c + FLOAT_HIGH], 0x8000

	add [c + FLOAT_EXP], 1
	ife ex, 0
		set pc, float__return

	set pc, float__return_inf

;----------------------------------------------------------------
:float__return_j
    set i, j

:float__return_i
    set j, [sp + 8]
    set [j], [i]
    set [j + FLOAT_EXP], [i + FLOAT_EXP]
    set [j + FLOAT_HIGH], [i + FLOAT_HIGH]
    set [j + FLOAT_LOW], [i + FLOAT_LOW]
    set pc, float__return

;----------------------------------------------------------------
:float__return_nan
    set a, FLOAT_TYPE_NAN
	set pc, float__return_a_type

;----------------------------------------------------------------
:float__return_inf
    set a, FLOAT_TYPE_NINF
    set pc, float__return_abs_a_type
;----------------------------------------------------------------
:float__return_pinf
    set a, FLOAT_TYPE_PINF
	set pc, float__return_a_type
;----------------------------------------------------------------
:float__return_ninf
    set a, FLOAT_TYPE_NINF
	set pc, float__return_a_type

;----------------------------------------------------------------
:float__return_zero
    set a, FLOAT_TYPE_PZERO
    set pc, float__return_abs_a_type
;----------------------------------------------------------------
:float__return_pzero
    set a, FLOAT_TYPE_PZERO
	set pc, float__return_a_type
;----------------------------------------------------------------
:float__return_nzero
    set a, FLOAT_TYPE_NZERO
	set pc, float__return_a_type

;----------------------------------------------------------------
:float__return_abs_a_type
    set i, [sp + 8]
    ifa [i], 0
        mli a, -1

:float__return_a_type
    set i, [sp + 8]
    set [i], a

:float__return
	set j, pop
	set i, pop
	set c, pop
	set b, pop
	set a, pop
	
	set pc, pop

;----------------------------------------------------------------
:nlz
; fastcall
;  i: float *f
; return
;  c: number of leading zeroes
;  a: garbage
;----------------------------------------------------------------
	set a, 0
	set b, [c + FLOAT_HIGH]
	ifb b, 0xffff
		set pc, nlz16

	set a, 16
	set b, [c + FLOAT_LOW]

:nlz16
	ifb b, 0xff00
		set pc, nlz8

	add a, 8
	shl b, 8
	
:nlz8
	ifb b, 0xf000
		set pc, nlz4

	add a, 4
	shl b, 4

:nlz4
	ifb b, 0xc000
		set pc, nlz2

	add a, 2
	shl b, 2

:nlz2
	ifb b, 0x8000
		set pc, pop

	add a, 1

    ifb b, 0x4000
        set pc, pop
    
	set a, 32
	set pc, pop




	

